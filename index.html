<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HTML Structure Map Generator</title>
  <link rel="manifest" href="manifest.json">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #222;
      color: white;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    input {
      margin: 20px;
    }
    #loading {
      font-size: 18px;
      margin-top: 10px;
      display: none;
    }
    #progressContainer {
      width: 50%;
      background: #444;
      height: 10px;
      margin: 10px auto;
      border-radius: 5px;
      display: none;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: limegreen;
      border-radius: 5px;
      transition: width 0.3s;
    }
    #container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    #graph-container {
      width: 70vw;
      height: 75vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #details-panel {
      width: 30vw;
      height: 75vh;
      background: #333;
      border-left: 1px solid white;
      padding: 10px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      display: none;
    }
    #details-panel h3 {
      margin-top: 0;
    }
    svg {
      width: 100%;
      height: 100%;
      border: 1px solid white;
      background: #333;
    }
    .link-label {
      font-size: 10px;
      fill: white;
    }
  </style>
</head>
<body>
  <h1>HTML Structure Map Generator</h1>
  <button id="install-button" hidden>Install App</button>
  <input type="file" id="fileInput" accept=".html">
  <div id="loading">Processing file...</div>
  <div id="progressContainer"><div id="progressBar"></div></div>
  <div id="container">
    <div id="graph-container"><svg></svg></div>
    <div id="details-panel">
      <h3>Node Details</h3>
      <pre id="details-content"></pre>
    </div>
  </div>

  <script>
      document.addEventListener("DOMContentLoaded", function() {
          // Register the service worker
          if ("serviceWorker" in navigator) {
              navigator.serviceWorker.register("service-worker.js");
          }
  
          let deferredPrompt;
          const installButton = document.getElementById("install-button");
  
          // Listen for the install prompt
          window.addEventListener("beforeinstallprompt", (e) => {
              e.preventDefault();
              deferredPrompt = e;
              installButton.hidden = false;
          });
  
          // Handle install button click
          installButton.addEventListener("click", async () => {
              const isStandalone = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
  
              if (isStandalone) {
                  console.log("App is already installed");
                  return;
              }
  
              if (deferredPrompt) {
                  deferredPrompt.prompt();
                  const { outcome } = await deferredPrompt.userChoice;
                  deferredPrompt = null;
                  console.log(outcome === "accepted" ? "User accepted install prompt" : "User dismissed install prompt");
              } else {
                  if (window.matchMedia("(display-mode: browser)").matches) {
                      window.location.assign("chrome://apps/");
                  }
              }
          });
      });
  </script>
  
  <script>
    const fileInput = document.getElementById('fileInput');
    const loading = document.getElementById('loading');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const detailsPanel = document.getElementById('details-panel');
    const detailsContent = document.getElementById('details-content');

    fileInput.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;

      loading.style.display = "block";
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";

      const reader = new FileReader();
      reader.onload = (e) => parseHTML(e.target.result);
      reader.onerror = () => {
        loading.innerText = "Error reading file!";
        resetUI();
      };
      reader.readAsText(file);
    });

    function updateProgress(percent) {
      progressBar.style.width = `${percent}%`;
    }

    function resetUI() {
      setTimeout(() => {
        loading.style.display = "none";
        progressContainer.style.display = "none";
      }, 1500);
    }

    function findFunctionEnd(scriptContent, startIndex) {
      let braceCount = 0;
      let i = startIndex;
      while (i < scriptContent.length) {
        if (scriptContent[i] === '{') braceCount++;
        else if (scriptContent[i] === '}') braceCount--;
        if (braceCount === 0) return i + 1;
        i++;
      }
      return scriptContent.length;
    }

    function parseHTML(html) {
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        if (!doc.body) throw new Error("Invalid HTML structure");

        const nodes = [];
        const links = [];
        let nodeId = 0;
        const nodeMap = new Map();
        const styleMap = new Map();
        const scriptContentMap = new Map();
        const elementMap = new Map();
        const variableMap = new Map();

        function addNode(name, type, parentId = null, content = null) {
          const id = nodeId++;
          nodes.push({ id, name, type, content });
          nodeMap.set(id, { name, type, content });
          if (parentId !== null) {
            links.push({ source: parentId, target: id, type: "structural" });
          }
          return id;
        }

        function traverseDOM(element, parentId = null) {
          if (!element || !element.tagName) return;

          const nodeName = element.id ? `#${element.id}` : element.tagName.toLowerCase();
          const currentId = addNode(nodeName, "element", parentId, element.outerHTML);
          if (element.id) {
            elementMap.set(`#${element.id}`, currentId);
            addNode(`#${element.id}`, "id", currentId);
          }
          if (element.classList.length) {
            element.classList.forEach(cls => {
              // Create or record a class node
              elementMap.set(`.${cls}`, currentId);
              addNode(`.${cls}`, "class", currentId);
            });
          }
          // NEW: Link inline styles to their element
          if (element.hasAttribute("style")) {
            const styleContent = element.getAttribute("style");
            // Create an inline style node as a child of the element
            addNode("Inline Style", "inline-style", currentId, styleContent);
          }
          [...element.children].forEach(child => traverseDOM(child, currentId));
        }

        function parseScriptContent(scriptContent, scriptId) {
          const funcRegex = /function\s+([a-zA-Z_]\w*)\s*\(([^)]*)\)/g;
          const callRegex = /([a-zA-Z_]\w*)\s*\([^)]*\)/g;
          const styleRegex = /\.className\s*=\s*['"]([^'"]+)['"]|\.style\./g;
          const elementRegex = /getElementById\s*\(['"]([^'"]+)['"]\)|querySelector\s*\(['"]([^'"]+)['"]\)/g;
          const varRegex = /(?:let|const|var)\s+([a-zA-Z_]\w*)\s*=([^;]*);/g;
          let match;

          const functions = new Map();
          scriptContentMap.set(scriptId, scriptContent);

          // Parse variables
          while ((match = varRegex.exec(scriptContent)) !== null) {
            const varName = match[1];
            const varValue = match[2].trim();
            const varId = addNode(`Variable: ${varName}`, "variable", scriptId, `Value: ${varValue}`);
            variableMap.set(varName, varId);
          }

          // Parse function declarations and store their code and id
          while ((match = funcRegex.exec(scriptContent)) !== null) {
            const funcName = match[1];
            const params = match[2].split(',').map(p => p.trim()).filter(p => p);
            const funcIndex = match.index;
            const funcEnd = findFunctionEnd(scriptContent, scriptContent.indexOf('{', funcIndex));
            const funcCode = scriptContent.substring(funcIndex, funcEnd);
            const funcId = addNode(`Function: ${funcName}`, "function", scriptId, funcCode);
            functions.set(funcName, { id: funcId, code: funcCode });

            params.forEach(param => {
              const paramId = addNode(`Input Variable: ${param}`, "input", funcId);
              links.push({ source: paramId, target: funcId, type: "input" });
            });
          }

          // Parse function calls and variable uses within each function
          funcRegex.lastIndex = 0;
          while ((match = funcRegex.exec(scriptContent)) !== null) {
            const funcName = match[1];
            const funcData = functions.get(funcName);
            const funcId = funcData.id;
            const funcIndex = match.index;
            const funcEnd = findFunctionEnd(scriptContent, scriptContent.indexOf('{', funcIndex));
            const funcCode = scriptContent.substring(funcIndex, funcEnd);

            let callMatch;
            const callRegexLocal = new RegExp(callRegex.source, "g");
            callRegexLocal.lastIndex = funcIndex;
            while ((callMatch = callRegexLocal.exec(funcCode)) !== null && callRegexLocal.lastIndex <= funcEnd) {
              const calledName = callMatch[1];
              if (functions.has(calledName) && calledName !== funcName) {
                const calledData = functions.get(calledName);
                links.push({ source: funcId, target: calledData.id, type: "function-call", label: `Calls: ${calledName}` });
              }
            }

            for (const [varName, varId] of variableMap) {
              const varUsageRegex = new RegExp(`\\b${varName}\\b`, "g");
              if (varUsageRegex.test(funcCode)) {
                links.push({ source: varId, target: funcId, type: "variable-use", label: `Uses: ${varName}`, visible: true });
              }
            }
          }

          // Global call regex for output linking
          while ((match = callRegex.exec(scriptContent)) !== null) {
            const callName = match[1];
            if (functions.has(callName)) {
              const callerId = scriptId;
              const calleeData = functions.get(callName);
              links.push({ source: callerId, target: calleeData.id, type: "output", label: `Output: ${callName}` });
            }
          }

          // Style usage linking remains unchanged
          while ((match = styleRegex.exec(scriptContent)) !== null) {
            const styleName = match[1] ? `.${match[1]}` : "JS Inline Style";
            const funcIds = Array.from(functions.values()).map(funcData => funcData.id);
            funcIds.forEach(funcId => {
              if (styleMap.has(styleName)) {
                links.push({ source: styleMap.get(styleName), target: funcId, type: "style-use", label: "Style Use", visible: true });
              }
            });
          }

          // NEW: Per-function element linking loop
          for (const [funcName, funcData] of functions.entries()) {
            let localMatch;
            const localElementRegex = new RegExp(elementRegex.source, "g");
            while ((localMatch = localElementRegex.exec(funcData.code)) !== null) {
              const elementId = localMatch[1] ? `#${localMatch[1]}` : localMatch[2];
              if (elementMap.has(elementId)) {
                links.push({ 
                  source: elementMap.get(elementId), 
                  target: funcData.id, 
                  type: "element-use", 
                  label: "Element Use", 
                  visible: true 
                });
              }
            }
          }

          // NEW: JavaScript-modified style linking loop
          for (const [funcName, funcData] of functions.entries()) {
            let localMatch;
            const jsStyleModRegex = /([a-zA-Z_]\w*)\.style\.([a-zA-Z_]\w*)\s*=/g;
            while ((localMatch = jsStyleModRegex.exec(funcData.code)) !== null) {
              const variableName = localMatch[1];
              const propertyName = localMatch[2];
              if (variableMap.has(variableName)) {
                const varId = variableMap.get(variableName);
                links.push({ source: varId, target: funcData.id, type: "js-style-mod", label: `Modifies ${propertyName}`, visible: true });
              }
            }
          }
        }

        function extractScriptsAndStyles(doc) {
          doc.querySelectorAll("script").forEach(script => {
            const src = script.src || "inline-script";
            const scriptId = addNode(src, "script");
            const parent = script.parentNode;
            if (parent && parent.tagName) {
              const parentId = nodes.find(n => n.name === parent.tagName.toLowerCase() || n.name === `#${parent.id}`)?.id;
              if (parentId !== undefined) {
                links.push({ source: parentId, target: scriptId, type: "structural" });
              }
            }
            if (!script.src && script.textContent) {
              parseScriptContent(script.textContent, scriptId);
            }
          });

          doc.querySelectorAll("link[rel='stylesheet'], style").forEach(style => {
            const isExternal = style.href;
            const href = isExternal ? style.href : "inline-stylesheet";
            const styleType = isExternal ? "external-style" : "stylesheet";
            const styleId = addNode(href, styleType, null, style.outerHTML);
            styleMap.set(href, styleId);
            const parent = style.parentNode;
            if (parent && parent.tagName) {
              const parentId = nodes.find(n => n.name === parent.tagName.toLowerCase() || n.name === `#${parent.id}`)?.id;
              if (parentId !== undefined) {
                links.push({ source: parentId, target: styleId, type: "structural" });
              }
            }
          });
        }

        function extractGameElements(doc) {
          const selectors = ["#player", ".platform", ".spike", ".teleporter", "#ground", "#gameOver"];
          selectors.forEach(selector => {
            doc.querySelectorAll(selector).forEach(element => {
              const gameId = addNode(selector, "game-element", null, element.outerHTML);
              const parent = element.parentNode;
              if (parent && parent.tagName) {
                const parentId = nodes.find(n => n.name === parent.tagName.toLowerCase() || n.name === `#${parent.id}`)?.id;
                if (parentId !== undefined) {
                  links.push({ source: parentId, target: gameId, type: "structural" });
                }
              }
            });
          });
        }

        // NEW: Link stylesheet nodes to elements that use their classes
        function linkStylesToElements(nodes) {
          nodes.forEach(node => {
            if (node.type === "element" && node.content) {
              const classMatch = node.content.match(/class\s*=\s*['"]([^'"]+)['"]/);
              if (classMatch) {
                const classes = classMatch[1].split(/\s+/);
                classes.forEach(cls => {
                  nodes.forEach(styleNode => {
                    if ((styleNode.type === "stylesheet" || styleNode.type === "external-style") && styleNode.content) {
                      if (styleNode.content.includes(`.${cls}`)) {
                        links.push({ source: styleNode.id, target: node.id, type: "stylesheet-use", label: `Applies .${cls}`, visible: true });
                      }
                    }
                  });
                });
              }
            }
          });
        }

        updateProgress(25);
        traverseDOM(doc.body);
        updateProgress(50);
        extractScriptsAndStyles(doc);
        updateProgress(75);
        extractGameElements(doc);
        // NEW: Link stylesheet rules to elements by class usage
        linkStylesToElements(nodes);
        updateProgress(100);

        setTimeout(() => {
          loading.innerText = "Map generated successfully!";
          resetUI();
          renderGraph(nodes, links, scriptContentMap);
        }, 500);
      } catch (error) {
        loading.innerText = `Error: ${error.message}`;
        resetUI();
      }
    }

    function renderGraph(nodes, links, scriptContentMap) {
      const svg = d3.select("svg");
      svg.selectAll("*").remove();
      const width = document.getElementById('graph-container').clientWidth;
      const height = document.getElementById('graph-container').clientHeight;

      const g = svg.append("g");
      const zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });
      svg.call(zoom);

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(200))
        .force("charge", d3.forceManyBody().strength(-500))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collide", d3.forceCollide(40))
        .force("x", d3.forceX(width / 2).strength(0.1))
        .force("y", d3.forceY(height / 2).strength(0.1));

      let focusedNodeId = null;
      let hasClickedEmptySpace = false;

      const link = g.append("g")
        .selectAll("g")
        .data(links)
        .join("g")
        .attr("class", d => d.type === "element-use" || d.type === "style-use" || d.type === "variable-use" || d.type === "js-style-mod" ? "dynamic-link" : "static-link");

      link.append("line")
        .attr("stroke", d => d.type === "input" ? "yellow" : d.type === "output" ? "orange" : d.type === "style-use" ? "green" : d.type === "element-use" ? "cyan" : d.type === "function-call" ? "purple" : d.type === "variable-use" || d.type === "js-style-mod" ? "magenta" : "white")
        .attr("stroke-width", 1.5)
        .attr("marker-end", "url(#arrow)")
        .style("visibility", "visible");

      svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 10)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "white");

      link.append("text")
        .attr("class", "link-label")
        .attr("dy", -5)
        .text(d => d.label || (d.type === "input" ? "Input" : d.type === "output" ? "Output" : d.type === "style-use" ? "Style Use" : d.type === "element-use" ? "Element Use" : d.type === "function-call" ? d.label : d.type === "variable-use" || d.type === "js-style-mod" ? d.label : ""))
        .style("visibility", "visible");

      const node = g.append("g")
        .selectAll("circle")
        .data(nodes)
        .join("circle")
        .attr("r", 10)
        .attr("fill", d => {
          switch (d.type) {
            case "element": return "blue";
            case "script": return "red";
            case "stylesheet":
            case "external-style": return "green";
            case "inline-style": return "orange";
            case "game-element": return "purple";
            case "function": return "pink";
            case "input": return "yellow";
            case "variable": return "magenta";
            default: return "gray";
          }
        })
        .on("click", (event, d) => {
          event.stopPropagation();
          detailsPanel.style.display = "block";
          focusedNodeId = d.id;
          hasClickedEmptySpace = false;
          if (d.type === "function") {
            detailsContent.textContent = d.content || "No function code available";
            const scale = 2;
            const x = -d.x * scale + width / 2;
            const y = -d.y * scale + height / 2;
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
          } else if (d.type === "script") {
            detailsContent.textContent = scriptContentMap.get(d.id) || "External script or no content";
          } else if (d.type === "element" || d.type === "game-element" || d.type === "stylesheet" || d.type === "external-style" || d.type === "inline-style") {
            detailsContent.textContent = d.content || `${d.name} (No additional details)`;
          } else {
            detailsContent.textContent = `${d.name} (Type: ${d.type})`;
          }
          updateVisibility();
        })
        .call(d3.drag()
          .on("start", dragStart)
          .on("drag", dragging)
          .on("end", dragEnd));

      svg.on("click", (event) => {
        if (event.target.tagName === "svg") {
          svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          detailsPanel.style.display = "none";
          detailsContent.textContent = "";
          focusedNodeId = null;
          hasClickedEmptySpace = true;
          updateVisibility();
        }
      });

      const labels = g.append("g")
        .selectAll("text")
        .data(nodes)
        .join("text")
        .attr("fill", "white")
        .attr("font-size", "12px")
        .attr("dx", 12)
        .attr("dy", 4)
        .text(d => d.name);

      simulation.on("tick", () => {
        link.select("line")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        link.select("text")
          .attr("x", d => (d.source.x + d.target.x) / 2)
          .attr("y", d => (d.source.y + d.target.y) / 2);

        node.attr("cx", d => d.x)
          .attr("cy", d => d.y);

        labels.attr("x", d => d.x)
          .attr("y", d => d.y);
      });

      function updateVisibility() {
        const connectedNodeIds = new Set();
        if (focusedNodeId !== null) {
          connectedNodeIds.add(focusedNodeId);
          links.forEach(link => {
            if (link.source.id === focusedNodeId) {
              connectedNodeIds.add(link.target.id);
              if (link.type === "element-use" || link.type === "style-use" || link.type === "variable-use" || link.type === "js-style-mod") link.visible = true;
            } else if (link.target.id === focusedNodeId) {
              connectedNodeIds.add(link.source.id);
              if (link.type === "element-use" || link.type === "style-use" || link.type === "variable-use" || link.type === "js-style-mod") link.visible = true;
            } else if (link.type === "element-use" || link.type === "style-use" || link.type === "variable-use" || link.type === "js-style-mod") {
              link.visible = false;
            } else if (link.type === "function-call") {
              if (link.source.id === focusedNodeId) {
                connectedNodeIds.add(link.target.id);
              }
            }
          });
        } else if (hasClickedEmptySpace) {
          links.forEach(link => {
            if (link.type === "element-use" || link.type === "style-use" || link.type === "variable-use" || link.type === "js-style-mod") {
              link.visible = false;
            }
          });
        }

        node.style("visibility", d => focusedNodeId === null || connectedNodeIds.has(d.id) ? "visible" : "hidden");
        labels.style("visibility", d => focusedNodeId === null || connectedNodeIds.has(d.id) ? "visible" : "hidden");

        link.select("line")
          .style("visibility", d => {
            if (d.type === "element-use" || d.type === "style-use" || d.type === "variable-use" || d.type === "js-style-mod") {
              return d.visible ? "visible" : "hidden";
            }
            if (d.type === "function-call") {
              return focusedNodeId !== null && d.source.id === focusedNodeId ? "visible" : "hidden";
            }
            return focusedNodeId === null || (d.source.id === focusedNodeId || d.target.id === focusedNodeId) ? "visible" : "hidden";
          })
          .style("opacity", d => {
            if (focusedNodeId === null && !hasClickedEmptySpace && (d.type === "element-use" || d.type === "style-use" || d.type === "variable-use" || d.type === "js-style-mod")) {
              return 0.3;
            }
            return 1;
          });

        link.select("text")
          .style("visibility", d => {
            if (d.type === "element-use" || d.type === "style-use" || d.type === "variable-use" || d.type === "js-style-mod") {
              return d.visible ? "visible" : "hidden";
            }
            if (d.type === "function-call") {
              return focusedNodeId !== null && d.source.id === focusedNodeId ? "visible" : "hidden";
            }
            return focusedNodeId === null || (d.source.id === focusedNodeId || d.target.id === focusedNodeId) ? "visible" : "hidden";
          })
          .style("opacity", d => {
            if (focusedNodeId === null && !hasClickedEmptySpace && (d.type === "element-use" || d.type === "style-use" || d.type === "variable-use" || d.type === "js-style-mod")) {
              return 0.3;
            }
            return 1;
          });

        simulation.alpha(0.1).restart();
      }

      function dragStart(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragging(event, d) {
        const transform = d3.zoomTransform(svg.node());
        d.fx = (event.x - transform.x) / transform.k;
        d.fy = (event.y - transform.y) / transform.k;
      }

      function dragEnd(event, d) {
        if (!event.active) simulation.alphaTarget(0.1);
        d.fx = null;
        d.fy = null;
      }

      updateVisibility();
    }
  </script>
</body>
</html>
